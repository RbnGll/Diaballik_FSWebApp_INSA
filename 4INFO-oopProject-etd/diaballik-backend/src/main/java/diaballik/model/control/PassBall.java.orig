package diaballik.model.control;

import diaballik.model.game.Game;
import diaballik.model.game.Tile;
import diaballik.model.player.Piece;
import diaballik.model.player.Player;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class PassBall extends Command {

    private Optional<Piece> fromPiece;

    private Optional<Piece> toPiece;

    public PassBall(final int x1, final int y1, final int x2, final int y2, final Game g) {
        super(x1, y1, x2, y2, g);
    }

    @Override
    public boolean exe() {
        return game.getCurrentPlayer().getBall().move(toPiece.get());
    }

    @Override
    public boolean canDo() {
<<<<<<< HEAD
        // Vérifier également si les coordonnées "from" et "to" sont dans le plateau ??
        return ifPiecesExists() && ifBelongToCurrentPlayer() && ifPieceHasBall() && ifCorrectPath() && ifNoPieceOnPath();
=======
        // Vérifier également si les coordonnées "from" et "to" sont dans le plateau ?? Non car vérifié dans setCurrentState
        return ifPiecesExists() && ifBelongToCurrentPlayer() && ifPieceHasBall() && ifCorrectPath() && ifNoOpponentOnPath();
>>>>>>> master
    }

    @Override
    public void redo() {
        this.exe();
    }

    @Override
    public void undo() {
        game.getCurrentPlayer().getBall().move(fromPiece.get());
    }

    public List<Tile> getPathTiles() {
        final List<Tile> path;

        final Tile fromTile = fromPiece.orElse(null).getTile();
        final Tile toTile = toPiece.orElse(null).getTile();

        if (fromTile != null && toTile != null) {
            final int dx = toTile.getX() - fromTile.getX();
            final int dy = toTile.getY() - fromTile.getY();

            // On suppose la trajectoire correcte (vérifié dans canDo())
            if (dx == 0) {
                path = IntStream
                        .range(fromTile.getY() + 1, toTile.getY())
                        .mapToObj(i -> game.getGameboard().getTile(fromTile.getX(), i))
                        .collect(Collectors.toList());
            } else if (dy == 0) {
                path = IntStream
                        .range(fromTile.getX() + 1, toTile.getX())
                        .mapToObj(i -> game.getGameboard().getTile(i, fromTile.getY()))
                        .collect(Collectors.toList());
            } else {
                path = IntStream
                        .range(fromTile.getX() + 1, toTile.getX())
                        .mapToObj(i -> game.getGameboard().getTile(i, i))
                        .collect(Collectors.toList());
            }

            return path;
        }
        return null;
    }

    public boolean ifPiecesExists() {
        return fromPiece.isPresent() && toPiece.isPresent();
    }

    public boolean ifBelongToCurrentPlayer() {
        final List<Piece> currentPlayerPieces = game.getCurrentPlayer().getPieces();
        return currentPlayerPieces.contains(fromPiece.get()) && currentPlayerPieces.contains(toPiece.get());
    }

    public boolean ifPieceHasBall() {
        return fromPiece.get().hasBall();
    }

    public boolean ifCorrectPath() {
        final int dx = toPiece.get().getTile().getX() - fromPiece.get().getTile().getX();
        final int dy = toPiece.get().getTile().getY() - fromPiece.get().getTile().getY();

        return (dx != 0 && dy == 0) || (dx == 0 && dy != 0) || (Math.abs(dx) == Math.abs(dy) && dx != 0);
    }

    public boolean ifNoPieceOnPath() {
        final List<Tile> path = this.getPathTiles();
        final Player player1 = game.getPlayer1();
        final Player player2 = game.getPlayer2();
        System.out.println(path);
        return path.stream().noneMatch(tile -> tile.getPiece().isPresent());

//        return !path.stream().anyMatch(tile -> {
//            final boolean test1 = tile.getPiece().isPresent();
//            final boolean test2 = player1.getPieces().contains(tile.getPiece().get());
//            final boolean test3 = player2.getPieces().contains(tile.getPiece().get());
//
//
//            return tile.getPiece().isPresent()
//                    && (player1.getPieces().contains(tile.getPiece().get())
//                    || player2.getPieces().contains(tile.getPiece().get()));
//        });
    }

    @Override
    public void setCurrentState() {
        if (game.getGameboard().ifWithinBounds(x1, y1) && game.getGameboard().ifWithinBounds(x2, y2)) {
            fromPiece = game.getGameboard().getTile(x1, y1).getPiece();
            toPiece = game.getGameboard().getTile(x2, y2).getPiece();
        } else {
            fromPiece = Optional.empty();
            toPiece = Optional.empty();
        }
    }

    public Optional<Piece> getFromPiece() {
        return fromPiece;
    }

    public Optional<Piece> getToPiece() {
        return toPiece;
    }

    @Override
    public String toString() {
        return "from" + fromPiece.get().getTile() + "to" + toPiece.get().getTile();
    }
}
